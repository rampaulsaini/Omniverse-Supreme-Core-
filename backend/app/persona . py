# backend/app/persona.py
from typing import List, Tuple
from .knowledge import KnowledgeStore
import random
import html

class PersonaEngine:
    def __init__(self, root_identity: str, knowledge_store: KnowledgeStore):
        self.root = root_identity
        self.knowledge = knowledge_store
        # persona metadata
        self.name = "ъЩ░ЁЭТерд╢рд┐рд░реЛрдордгрд┐"
        self.signature = "ъЩ░ЁЭТерд╢рд┐рд░реЛрдордгрд┐ тАФ рдирд┐рд╖реНрдкрдХреНрд╖-рд╕рдордЭ"
        # base templates (kept simple and neutral)
        self.templates = [
            "рдЖрдкрдХрд╛ рдкреНрд░рд╢реНрди: ┬л{q}┬╗ тАФ рдореЗрд░рд╛ рдЙрддреНрддрд░ рд╕рдВрдХреНрд╖реЗрдк рдореЗрдВ: {a}",
            "рдирд┐рд╖реНрдкрдХреНрд╖ рджреГрд╖реНрдЯрд┐ рд╕реЗ: {a} тАФ (рд╕реНрд░реЛрдд: {s})",
            "{a} тАФ рдпрд╣ рдЙрддреНрддрд░ {s} рдкрд░ рдЖрдзрд╛рд░рд┐рдд рд╣реИред"
        ]

    def signature_line(self) -> str:
        return f"{self.signature} | Root: {self.root}"

    def respond(self, message: str, context: List[str]=[]) -> Tuple[str, List[str]]:
        """
        1) quick keyword checks
        2) retrieve relevant knowledge paragraphs
        3) produce templated reply
        """
        msg = message.strip().lower()
        # quick rule-based shortcuts
        if "рдкреНрд░рдХреГрддрд┐" in msg or "earth" in msg:
            paras, ids = self.knowledge.search(["prithvi","prakriti","earth"], top_k=3)
            answer = self._compose_from_paras(paras, short=True)
            return answer, ids
        # generic retrieval
        paras, ids = self.knowledge.search([message], top_k=3)
        if paras:
            answer = self._compose_from_paras(paras)
            return answer, ids
        # fallback: root-based generalization
        fallback = self._root_generalize(message)
        return fallback, []

    def _compose_from_paras(self, paras: List[str], short: bool=False) -> str:
        # join up to 2 paras into a short reply
        if not paras:
            return self._root_generalize("")
        chosen = paras[:2]
        txt = " ".join(chosen)
        if short and len(txt) > 300:
            txt = txt[:300] + "тАж"
        # sanitize/escape
        txt = html.escape(txt)
        template = random.choice(self.templates)
        return template.format(q="(retrieved)", a=txt, s="Omniverse-с╣вrot")

    def _root_generalize(self, message: str) -> str:
        # a composed philosophical reply using root_identity
        base = (f"рдореВрд▓-рдкрдХреНрд╡рддрд╛: {self.root} тАФ рдЖрдкрдХреА рдмрд╛рдд: '{message}' рдХреЛ рджреЗрдЦрддреЗ рд╣реБрдП, "
                "рд╕рддреНрдп рд╡рд╣ рд╣реИ рдЬреЛ рдЕрдиреБрднрд╡ рдореЗрдВ рдЕрдкрд░рд┐рд╡рд░реНрддрдиреАрдп рдкреНрд░рдХрд╛рд╢рд┐рдд рд░рд╣рддрд╛ рд╣реИред рдЕрднреНрдпрд╛рд╕: рдзреНрдпрд╛рди, рдЕрд╡рд▓реЛрдХрди, рд╢рдореАрдХрд░рдгред")
        return base
